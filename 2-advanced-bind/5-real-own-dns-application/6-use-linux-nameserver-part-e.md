# Note on Docker container, Docker compose, Kubernetes and OpenShift 

In [part A](6-use-linux-nameserver-part-a.md), we had deployed application which are behind a DNS.
Those application were deployed directly on the machine. 
But we could have deployed them via:
- Docker container directly
- Docker container via docker compose
- Docker container deployed via Kubernetes

In [part B](6-use-linux-nameserver-part-b.md), we had deployed a DNS (used by application) via Docker container deployed via Kubernetes.
And same apply as a normal application.

````shell script
we ssh to hp machine
ssh sylvain@109.29.148.109
````
<!-- commit, push, pull from hp -->

## Show we can deploy DNS via Docker container directly 

````shell script
sudo docker run -d -p 32048:53/udp --name mydns_3 dns-ubuntu
````

Note you need to define port [forwarding](https://docs.docker.com/config/containers/container-networking/) and set UDP here, otherwise it won't work: 
It is a good practise to [document it](https://docs.docker.com/engine/reference/builder/#expose) in the [Dockerfile](./6-docker-bind-dns-use-linux-nameserver-rather-route53/dns-ubuntu.Dockerfile).

Then test it

````shell script
nslookup -port=32048 scoulomb.coulombel.it 127.0.0.1
sudo docker exec mydns_3  /bin/sh -c "nslookup scoulomb.coulombel.it 127.0.0.1"
nslookup scoulomb.coulombel.it 
nslookup scoulomb.coulombel.it 8.8.8.8
````

Output is 


````shell script
sylvain@sylvain-hp:~/myDNS_hp$ nslookup -port=32048 scoulomb.coulombel.it 127.0.0.1
Server:         127.0.0.1
Address:        127.0.0.1#32048

Name:   scoulomb.coulombel.it
Address: 41.41.41.41

sylvain@sylvain-hp:~/myDNS_hp$ sudo docker exec mydns_3  /bin/sh -c "nslookup scoulomb.coulombel.it 127.0.0.1"
Server:         127.0.0.1
Address:        127.0.0.1#53

Name:   scoulomb.coulombel.it
Address: 41.41.41.41

sylvain@sylvain-hp:~/myDNS_hp$ cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 127.0.0.53

sylvain@sylvain-hp:~/myDNS_hp$ nslookup scoulomb.coulombel.it
Server:         127.0.0.53
Address:        127.0.0.53#53

Non-authoritative answer:
Name:   scoulomb.coulombel.it
Address: 41.41.41.41

sylvain@sylvain-hp:~/myDNS_hp$ nslookup scoulomb.coulombel.it 8.8.8.8
Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
Name:   scoulomb.coulombel.it
Address: 41.41.41.41

````

Last two one is via the registrar.
If we now kills the DNS docker container.

````shell script
sudo docker kill mydns_3
````

Some will be cached but after 3 requests will fail when using google.
SFR is caching longer but will eventually fail.

````shell script
$ nslookup scoulomb.coulombel.it
Server:         127.0.0.53
Address:        127.0.0.53#53

Non-authoritative answer:
Name:   scoulomb.coulombel.it
Address: 41.41.41.41

$ nslookup scoulomb.coulombel.it
Server:         127.0.0.53
Address:        127.0.0.53#53

** server can't find scoulomb.coulombel.it: SERVFAIL


$ nslookup scoulomb.coulombel.it 8.8.8.8
Server:         8.8.8.8
Address:        8.8.8.8#53

** server can't find scoulomb.coulombel.it: SERVFAIL
````

Deploying the DNS locally via Docker make us realize issue oberve in [part D](6-use-linux-nameserver-part-d.md).
So it is a good idea to test your image locally.

## Show we can deploy application behind via Docker and Kubernetes

### With Docker 

````shell script
cd ./2-advanced-bind/5-real-own-dns-application/6-part-e-contenarized-http-server
sudo docker build . -f a.Dockerfile -t a-server
sudo docker build . -f b.Dockerfile -t b-server
sudo docker run -p 8081:8080 a-server
sudo docker run -p 8082:8080 b-server

curl localhost:8081
curl localhost:8082
````

Ouptut of curl is 

````shell script
sylvain@sylvain-hp:~$ curl localhost:8081
Hello app A
sylvain@sylvain-hp:~$ curl localhost:8082
Hello app B
````
### With Docker-compose

````shell script
sudo docker-compose up -d

curl localhost:8081
curl localhost:8082
````

ouptput is 

````shell script
$ curl localhost:8081
Hello app A
$ curl localhost:8082
Hello app B
````

Note inside docker image a service resolution is performed:


````shell script
sudo docker exec -it 6-part-e-contenarized-http-server_server-b_1 curl server-a:8080
sudo docker exec -it 6-part-e-contenarized-http-server_server-b_1 curl server-b:8080
sudo docker exec -it 6-part-e-contenarized-http-server_server-a_1 curl server-a:8080
sudo docker exec -it 6-part-e-contenarized-http-server_server-a_1 curl server-b:8080
````

Output is

````shell script
sylvain@sylvain-hp:~$ sudo docker exec -it 6-part-e-contenarized-http-server_server-b_1 curl server-a:8080
Hello app A
sylvain@sylvain-hp:~$ sudo docker exec -it 6-part-e-contenarized-http-server_server-b_1 curl server-b:8080
Hello app B
sylvain@sylvain-hp:~$ sudo docker exec -it 6-part-e-contenarized-http-server_server-a_1 curl server-a:8080
Hello app A
sylvain@sylvain-hp:~$ sudo docker exec -it 6-part-e-contenarized-http-server_server-a_1 curl server-b:8080
Hello app B
````

### With Kubernetes

### Kubernetes with IP

````shell script
ssh sylvain@109.29.148.109
sudo minikube start --vm-driver=none
sudo su
kubectl run a-server --image=a-server --restart=Never --image-pull-policy=Never 
kubectl run b-server --image=b-server --restart=Never --image-pull-policy=Never 

# port=target port if unspecified
sudo kubectl expose pod a-server --port 80 --target-port 8080 --protocol=TCP --type=NodePort 
sudo kubectl expose pod b-server --port 80 --target-port 8080 --protocol=TCP --type=NodePort
````


Then we can curl it via nodePort 

````shell script
export aNodePort=$(kubectl get svc a-server -o jsonpath='{.spec.ports[0].nodePort}{"\n"}')
export bNodePort=$(kubectl get svc b-server -o jsonpath='{.spec.ports[0].nodePort}{"\n"}')

curl 127.0.0.1:$aNodePort
curl 127.0.0.1:$bNodePort 

# private lan ip
curl 192.168.1.32:$aNodePort
curl 192.168.1.32:$bNodePort

# public ip
curl 109.29.148.109:$aNodePort
curl 109.29.148.109:$bNodePort


````

Output is

````shell script
root@sylvain-hp:/home/sylvain# curl 127.0.0.1:$aNodePort
Hello app A
root@sylvain-hp:/home/sylvain# curl 127.0.0.1:$bNodePort
Hello app B
root@sylvain-hp:/home/sylvain# curl 192.168.1.32:$aNodePort
Hello app A
root@sylvain-hp:/home/sylvain# curl 192.168.1.32:$bNodePort
Hello app B


root@sylvain-hp:/home/sylvain# curl 109.29.148.109:$bNodePort
^C
````

If we set NAT rule in router 

````shell script
root@sylvain-hp:/home/sylvain# echo $bNodePort
31165
root@sylvain-hp:/home/sylvain# echo $aNodePort
30389
==> 
NodePort	TCP	Port	30389	192.168.1.32	30389		
Nodeport	TCP	Port	31165	192.168.1.32	31165
````

output is

```shell script
root@sylvain-hp:/home/sylvain# curl 109.29.148.109:$aNodePort
Hello app A
root@sylvain-hp:/home/sylvain# curl 109.29.148.109:$bNodePort
Hello app B
```

Note there aree various ways to use service, we have an exhaustive list in [use linux nameserver shell script](6-docker-bind-dns-use-linux-nameserver-rather-route53/6-use-linux-nameserver.sh).
Where it is applied to the DNS itself.

#### Kubernetes with own DNS

We will deploy with the DNS which is in front of our Dockerized server application.
We will redeploy our Dockerized application.

````shell script
cd $project
sudo su # not sudo -i to keep current directory 
minikube start --vm-driver=none
./2-advanced-bind/5-real-own-dns-application/6-docker-bind-dns-use-linux-nameserver-rather-route53/6-use-linux-nameserver.sh

kubectl run a-server --image=a-server --restart=Never --image-pull-policy=Never 
kubectl run b-server --image=b-server --restart=Never --image-pull-policy=Never 


# We need this to reuse the same port. We can use expose when we wat to specify NodePort
temp_file=$(sudo mktemp)
sudo chmod 777 ${temp_file}
sudo cat << FIN > ${temp_file}
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    run: a-server
  name: a-server
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 8080
    nodePort: 30389
  selector:
    run: a-server
  type: NodePort
status:
  loadBalancer: {}
FIN
sudo cat ${temp_file}
sudo kubectl apply -f ${temp_file}
sudo rm $temp_file

temp_file=$(sudo mktemp)
sudo chmod 777 ${temp_file}
sudo cat << FIN > ${temp_file}
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    run: b-server
  name: b-server
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 8080
    nodePort: 31165
  selector:
    run: b-server
  type: NodePort
status:
  loadBalancer: {}
FIN
sudo cat ${temp_file}
sudo kubectl apply -f ${temp_file}
sudo rm $temp_file
````

So that we can test

````shell script
curl 109.29.148.109:$aNodePort
curl 109.29.148.109:$bNodePort
````

Output is 

````shell script
root@sylvain-hp:/home/sylvain/myDNS_hp# curl 109.29.148.109:$aNodePort
Hello app A
root@sylvain-hp:/home/sylvain/myDNS_hp# curl 109.29.148.109:$bNodePort
Hello app B
root@sylvain-hp:/home/sylvain/myDNS_hp#
````

We will now show we can use

````shell script
home             IN      CNAME     scoulomb.ddns.net.
````


For this demo, I will remove from SFR internal DNS following entry (used for DNS switch but some side effect when using on machine which we are pointing to)
So that we also use public IP here.

Remove entry: http://192.168.1.1/network/dns
```shell script
192.168.1.32	home.coulombel.it
```

Otherwise we have

````shell script
root@sylvain-hp:/home/sylvain/myDNS_hp# nslookup home.coulombel.it
Server:         127.0.0.53
Address:        127.0.0.53#53

Non-authoritative answer:
Name:   home.coulombel.it
Address: 192.168.1.32
home.coulombel.it       canonical name = scoulomb.ddns.net.

root@sylvain-hp:/home/sylvain/myDNS_hp# ping home.coulombel.it
PING scoulomb.ddns.net (109.29.148.109) 56(84) bytes of data.
64 bytes from 109.148.29.109.rev.sfr.net (109.29.148.109): icmp_seq=1 ttl=64 time=0.478 ms
64 bytes from 109.148.29.109.rev.sfr.net (109.29.148.109): icmp_seq=2 ttl=64 time=0.520 ms
````

Once it is removed we have

```shell script
root@sylvain-hp:/home/sylvain/myDNS_hp# nslookup home.coulombel.it
Server:         127.0.0.53
Address:        127.0.0.53#53

Non-authoritative answer:
home.coulombel.it       canonical name = scoulomb.ddns.net.
Name:   scoulomb.ddns.net
Address: 109.29.148.109
```

Now we can use our own nameserver and access our python application deployed behind it

````shell script
curl home.coulombel.it:$aNodePort
curl home.coulombel.it:$bNodePort
````

Output is 

````shell script
root@sylvain-hp:/home/sylvain/myDNS_hp# curl home.coulombel.it:$aNodePort
Hello app A
root@sylvain-hp:/home/sylvain/myDNS_hp# curl home.coulombel.it:$bNodePort
Hello app B
````

anf it would work on any machine on internet (here windows)

````shell script
$ curl home.coulombel.it:30389
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    12  100    12    0     0    571      0 --:--:-- --:--:-- --:--:--   571Hello app A
````

In next section we will see how we can get ride of NodePort concern and use ingress rules.
